## To do
- [x] 用户侧：封装更高层次的读取方法，支持逐股票筛选
- [x] 服务侧：缓存淘汰方法完善
- [x] 服务侧：增加请求队列，使能够同时处理多个请求
- [x] 用户侧：长轮询机制，等待服务侧加载
- [x] 用户侧：类销毁减引用和清理操作
- [ ] 服务侧：增加日志记录
- [ ] 服务侧：异常处理和测试用例完善
- [ ] 服务测：多进程并发处理

## 讨论
当某data_id正在加载（在load_que中/正在被load）时，接收到别的用户对相同id的请求，服务能够正确处理吗？：
- 两种情况：
  - 当cache_usage未达到上限是：会走到 `ready_to_load` 方法，重复入队`load_que`，但不会重复加载，同时cache_order也能保证正确更新；同时由于 `get_cache_info` 方法拿不到信息，最终客户端收到wait从而进入轮询
  - 当cache_usage达到上限时：方法进入